---
title: "Session 3: building containers"
teaching: 10
exercises: 50
questions:
objectives:
---


### Goals

In this session, we're going to build together three simple container images.

In particular we'll cover:
* one RStudio image;
* one Conda image;
* one image where we're building the software ourselves.

As we've seen in the dedicated webinar, here the key tool is not Singularity but Docker, due to the higher compatibility and overwhelming popularity of its container image format.  
We're going to touch on relevant aspects of writing a Dockerfile:
* choosing an appropriate base image;
* using `RUN` to execute commands;
* using `ENV` to define environment variables;
* other useful commands;
* best practices.

Then, we're going to explore all the required steps in the creation of a container image:
* building an image with `docker build`;
* sharing it on a public registry with `docker push`;
* converting it for usage with Singularity, with `singularity pull docker-daemon:`.

To brush up on building container images with Docker, you can refer to the webinar episode [Building images with Docker](https://pawseysc.github.io/singularity-containers/22-build-docker/index.html).

Writing a Dockerfile for a container is an art, which you can refine over time with practice.  
We don't mean to be exhaustive in this session; instead, we hope to provide you with the basic and most common commands, as well as some good practices.


### GUIDED - Let's have a look at the Dockerfile for R Tidyverse

Picking an appropriate base image is an important step in writing a Dockerfile.  A suitable base image can save us a lot of time, in providing pre-installed tools we need, provided it is an image we can trust in terms of quality and functionality.

Our first exercise in writing a Dockerfile is around an R package.  The [Rocker project](https://www.rocker-project.org) provides good quality images for R and RStudio.  Here we're going to use the [Tidyverse image](https://hub.docker.com/r/rocker/tidyverse), which includes R, RStudio and also the [Tidyverse](https://www.tidyverse.org) collection of data science packages.  

Let's have a look at its [Dockerfile](https://github.com/rocker-org/rocker-versioned/blob/master/tidyverse/3.6.1.Dockerfile):

```
FROM rocker/rstudio:3.6.1

RUN apt-get update -qq && apt-get -y --no-install-recommends install \
  libxml2-dev \
  libcairo2-dev \
  libsqlite3-dev \
  libmariadbd-dev \
  libmariadb-client-lgpl-dev \
  libpq-dev \
  libssh2-1-dev \
  unixodbc-dev \
  libsasl2-dev \
  && install2.r --error \
    --deps TRUE \
    tidyverse \
    dplyr \
    devtools \
    formatR \
    remotes \
    selectr \
    caTools \
    BiocManager
```
{: .source}

Let's refresh some essential key instructions in Dockerfiles.


> ## How do we specify the base image in a Dockerfile?
> 
> Can you identify the line with the base image?  What is the Docker instruction to declare it?
> 
> > ## Solution
> > 
> > The line is: 
> > 
> > ```
> > FROM rocker/rstudio:3.6.1
> > ```
> > {: .source}
> > 
> > The Docker instruction to specify the base image is `FROM`.
> > 
> > Note how the base image is not a simple Linux OS image such as Ubuntu or Centos.  Instead, it's another image by Rocker, `rocker/rstudio:3.6.1`.  
> > In turn, if we had a look at the Dockerfile for this latter image, we'd find it's based on `rocker/r-ver:3.6.1`, *i.e.* the plain *R* image by Rocker.  This one is based on the Debian OS image `debian:stretch`.  
> > This shows how it is possible to build complex containers in steps over multiple builds, by making use of increasingly more specialised images.
> {: .solution}
{: .challenge}


> ## How do we run commands in a Dockerfile?
> 
> Can you tell what is the Docker instruction to run shell commands in a Dockerfile?
> 
> > ## Solution
> > 
> > The Docker instruction to execute commands is `RUN`.  
> > 
> > Here, the Debian/Ubuntu package manager `apt` is used to install a set of prerequisites for Tidyverse.  
> > Then, the R utility `install2.r` (from the package *littler*) is used to install `tidyverse` and other packages, including `BiocManager` (the installer for [BioConductor](https://bioconductor.org) packages).  
> > 
> > If you were installing Tidyverse without containers, these could be the very same commands to execute inside a Linux shell to get the job done.  The only difference in this Dockerfile is the use of the Docker syntax `RUN`.
> {: .solution}
{: .challenge}


### ROOM - Write an R Dockerfile

Now it's your turn!

First, cd into the appropriate directory:

```
$ cd /data/containers-bioinformatics-workshop
$ export WORK=$(pwd)
$ cd exercises/build/r-ggtree
```
{: .bash}

Now you're going to write a little Dockerfile for the R package `ggtree`.  The end result will actually be the RStudio image that is used in the session on graphical applications.


> ## Start writing the Dockerfile
> 
> Create a blank file called `Dockerfile`, and as first thing write a line that specifies the base image to be `rocker/tidyverse:3.6.1`, *i.e.* the image whose Dockerfile we have just commented on.
> 
> > ## Solution
> > 
> > ```
> > FROM rocker/tidyverse:3.6.1
> > ```
> > {: .source}
> > 
> > Good!  Now, the package `ggtree` is part of the BioConductor project.  So, from inside an R console you could install it by using the command `BiocManager::install("ggtree")`.  However, here we need to execute this command from the bash shell.
> {: .solution}
{: .challenge}


> ## A non-container question
> 
> If you are an R user, do you know how you can execute the R command above from the shell?  No worries, just have a look at the solution if you don't.
> 
> > ## Solution
> > 
> > ```
> > R -e 'BiocManager::install("ggtree")'
> > ```
> {: .solution}
{: .challenge}


> ## Install an R package in the Dockerfile
> 
> You're almost there... now just embed the shell command above in your Dockerfile, by using the appropriate Docker instruction.
> 
> > ## Solution
> > 
> > ```
> > FROM rocker/tidyverse:3.6.1
> > 
> > RUN R -e 'BiocManager::install("ggtree")'
> > ```
> > {: .source}
> > 
> > That's it!  You've written a simple Dockerfile to install an R package on top of an R base image.
> > 
> > Very often (albeit not always) preparing Dockerfiles for R images looks as simple as this.  Other times, you will also need to install documented pre-requisites as in the Tidyverse example above.  And of course things can at times get more complicated than this.
> {: .solution}
{: .challenge}


> ## Build the image!
> 
> Now it's the time for building.  
> Use the appropriate Docker syntax in the shell, to build an image called `ggtree:2.0.4`, assuming you're running from the directory where the Dockerfile is. 
> 
> > ## Solution
> > 
> > ```
> > $ sudo docker build -t ggtree:2.0.4 .
> > ```
> > {: .bash}
> > 
> > It will only take a couple of minutes to build, as most required R packages are already provided by the base Tidyverse image! 
> > 
> > Note how here we gave you the information about the package version; normally you would be able to find it out yourself after the first build, by inspecting the R installation in the container.
> {: .solution}
{: .challenge}


### ROOM - Write a Conda Dockerfile






### ROOM - Write a Dockerfile to build a tool




### ROOM - Feeder questions



### GUIDED - Share and convert the image


### GUIDED - Best practices