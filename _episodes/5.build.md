---
title: "Session 3: building containers"
teaching: 20
exercises: 40
questions:
objectives:
---


### Goals

In this session, we're going to build together three simple container images.

In particular we'll cover:
* one RStudio image;
* one Conda image;
* one image where we're building the software ourselves.

As we've seen in the dedicated webinar, here the key tool is not Singularity but Docker, due to the higher compatibility and overwhelming popularity of its container image format.  
We're going to touch on relevant aspects of writing a Dockerfile:
* choosing an appropriate base image and declaring it with `FROM`;
* using `RUN` to execute commands;
* using `ENV` to define environment variables;
* other useful commands;
* best practices.

Then, we're going to explore the typical steps that are required in the creation of a container image:
* building an image with `docker build`;
* testing and debugging it with `docker run`;
* sharing it on a public registry with `docker push`;
* converting it for usage with Singularity, with `singularity pull docker-daemon:`.

To brush up on building container images with Docker, you can refer to the webinar episode [Building images with Docker](https://pawseysc.github.io/singularity-containers/22-build-docker/index.html).

Writing a Dockerfile for a container is an art, which you can refine over time with practice.  
We don't mean to be exhaustive in this session; instead, we hope to provide you with the basic and most common commands, as well as some good practices.


### GUIDED - Let's write an R Dockerfile

The first exercise in this session is to write a little Dockerfile for the R package `ggtree`.  This package provides functionalities to represent phylogenetic trees using R, by building on top of the [Tidyverse](https://www.tidyverse.org) collection of data science packages, and in particular the plotting library `ggplot2`.  
The end result will actually be the RStudio image that is used in the session on graphical applications.

The first step in designing a Dockerfile is to choose a base image, that is the starting point for our container.

The best place to find useful base image is the [Docker Hub](https://hub.docker.com) online registry.  Here is a non-comprehensive list of potentially useful base images (the version tags are not necessarily the most recent ones):

* OS images, such as `ubuntu:18.04`, `debian:buster` and `centos:7`;
* R images, in particular the `rocker/` repository by the [Rocker project](https://www.rocker-project.org):
    - Base R: `rocker/r-ver:3.6.1`;
    - RStudio: `rocker/rstudio:3.6.1`;
    - Tidyverse+RStudio: `rocker/tidyverse:3.6.1`;
  * Python images, such as `python:3.8` and `python:3.8-slim` (a lightweight version);
  * Conda images by [Anaconda](https://www.anaconda.com), such as `miniconda3:4.8.2`;
  * Jupyter images, in particular the `jupyter/` images by Jupyter Docker Stacks (unfortunately using the `latest` tag), for instance:
    - Base Jupyter: `jupyter/base-notebook:latest`;
    - Jupyter with scientific Python packages: `jupyter/scipy-notebook:latest`;
    - *Data science* Jupyter, including Python, scientific Python packages, R, Tidyverse and more: `jupyter/datascience-notebook:latest`.

Now, let's cd into the appropriate directory:

```
$ cd /data/containers-bioinformatics-workshop
$ export WORK=$(pwd)
$ cd exercises/build/r-ggtree
```
{: .bash}

And then use a text editor to create a blank `Dockerfile`.


> ## Pick the base image
> 
> Considering the characteristic that we stated above for the `ggtree` package, which is the simplest base image you would choose from this list?
> 
> > ## Solution
> > 
> > We need R and Tidyverse, so let's go with `rocker/tidyverse:3.6.1`.
> {: .solution}
> 
> Now we need to declare this image in the Dockerfile, using an appropriate Docker instruction.
> 
> > ## Solution
> > 
> > ```
> > FROM rocker/tidyverse:3.6.1
> > ```
> > {: .source}
> {: .solution}
{: .challenge}


> ## A non-container question
> 
> The package `ggtree` is part of the BioConductor project.  So, from inside an R console we could install it by using the command `BiocManager::install("ggtree")`.  However, here we need Docker to execute this command from a bash shell.
> 
> If you are an R user, do you know how you can execute the R command above from the shell?  No worries if you don't, just have a look at the solution.
> 
> > ## Solution
> > 
> > ```
> > R -e 'BiocManager::install("ggtree")'
> > ```
> > {: .source}
> {: .solution}
{: .challenge}


> ## Command to install an R package
> 
> We're almost there with our first Dockerfile... now we just need to embed the shell command above in the Dockerfile, by using the appropriate Docker instruction.
> 
> > ## Solution
> > 
> > ```
> > FROM rocker/tidyverse:3.6.1
> > 
> > RUN R -e 'BiocManager::install("ggtree")'
> > ```
> > {: .source}
> > 
> > Very often (albeit not always) preparing Dockerfiles for R images looks as simple as this.  Other times, you will also need to install documented pre-requisites as in the Tidyverse example above.  And of course things can at times get more complicated than this.
> {: .solution}
{: .challenge}


> ## Build the image
> 
> Now it's the time for building.  
> Let' use the appropriate `docker` syntax in the shell, to build an image called `ggtree:2.0.4`; remember we're running from the directory where the Dockerfile is (`.`). 
> 
> > ## Solution
> > 
> > ```
> > $ sudo docker build -t ggtree:2.0.4 .
> > ```
> > {: .bash}
> > 
> > It will only take a couple of minutes to build, as most required R packages are already provided by the base Tidyverse image.
> {: .solution}
> 
> Note how here we provided the information about the package version; normally we would be able to find it out yourself after the first build, by inspecting the R installation in the container.  Let's do it.
{: .challenge}


> ## Test the image
> 
> In order to test that the image we built actually contains a working version of `ggtree`, we're going to execute the following shell command to print the version of this package, from inside the container:
> 
> ```
> $ R -e 'packageVersion("ggtree")'
> ```
> {: .bash}
> 
> Here's something new for you: if you want to run a container with Docker, you need to execute `docker run`; then, similar to Singularity, we need to append the image name and the command.
> 
> > ## Solution
> > 
> > ```
> > $ docker run ggtree:2.0.4 R -e 'packageVersion("ggtree")'
> > ```
> > {: .bash}
> > 
> > ```
> > R version 3.6.1 (2019-07-05) -- "Action of the Toes"
> > Copyright (C) 2019 The R Foundation for Statistical Computing
> > Platform: x86_64-pc-linux-gnu (64-bit)
> > 
> > [..]
> > 
> > > packageVersion("ggtree")
> > [1] ‘2.0.4’
> > > 
> > > 
> > ```
> > {: .output}
> > 
> > It has worked!  The container has got `ggtree` version 2.0.4.
> {: .solution}
{: .challenge}


### ROOM - Write a Conda Dockerfile

In this exercise you're going to use the *Conda* package manager to install a popular bioinformatics tool, *samtools*.  
The [Anaconda](https://www.anaconda.com) developers provide a good base image to this end, namely the [miniconda3](https://hub.docker.com/r/continuumio/miniconda3) base image.





> ## Use Conda in a Dockerfile
> 
> Cd into the appropriate directory:
> 
> ```
> $ cd ../conda-samtools
> ```
> {: .bash}
> 
> Now, let's use `continuumio/miniconda3:4.8.2` as the base image for a Dockerfile that installs *samtools*.  
> 
> Samtools can be installed with Conda through the channel *bioconda*, so the shell syntax would be (`-y` is to confirm prompts):
> 
> ```
> conda install -y -c bioconda samtools
> ```
> {: .bash}
> 
> With this information, write the Dockerfile to install samtools using Conda.
> 
> > ## Solution
> > 
> > ```
> > FROM continuumio/miniconda3:4.8.2
> > 
> > RUN conda install -y -c bioconda samtools
> > ```
> > {: .source}
> > 
> > Similar to the case of R, Dockerfiles often turn out to be quite compact when using a `conda` base image.  Things are not always this easy, as for instance package version conflicts are common with Conda;  additional command lines might be required to work around them, or you might even need to install packages entirely manually.
> {: .solution}
{: .challenge}


> ## Build the image!
> 
> Similar to the previous exercise, what is the appropriate `docker` shell command to build an image called `samtools-conda:1.9`? (again we're providing version information to you)
> 
> > ## Solution
> > 
> > ```
> > $ sudo docker build -t samtools-conda:1.9 .
> > ```
> > {: .bash}
> > 
> > The build should only take a couple of minutes.
> {: .solution}
{: .challenge}












### ROOM - Write a Dockerfile to build a tool


> Note how backslashes `\` followed by newlines are used to improve the readability of the bash code.







## A useful Docker instruction

The `ARG` instruction can be used to define variables in the Dockerfile, that only exist within the build process.  This can be especially useful to specify package versions in a more general and flexible way.

For instance, you could define a variable for the samtools version:

```
ARG SAM_VER="1.9"
```
{: .source}

And then, in the `conda install` command, substitute the version `1.9` with `$SAM_VER`.







### ROOM - Feeder questions



### GUIDED - Share and convert the image

### GUIDED - Best practices

RUN: layers, clean
ENV: locale, no-interactive
ARG
CMD
LABEL






> ## Some `RUN` best practices
> 
> Note how multiple shell commands are grouped into a single `RUN` execution by using the Linux syntax `&&`; it instructs the shell (or Docker here) to execute the following command only if the previous one has ended successfully (with no error).  
> Grouping commands into single `RUN`s is a good practice when building Docker images, as it reduces the number of image caching *layers*, and thus the total size of the image.  To be most effective, you would group together commands that relate to the same component of the installation, *e.g.* all *miniconda*-related commands.
> 
> Also note another best practice to reduce the size of the final image: cleaning up the installation process.  
> In this specific case, this is achieved with `apt-get clean` for the Linux `apt` installation, and with the following sequence of commands for `conda` (see also Dockerfile above):
> 
> ```
>     find /opt/conda/ -follow -type f -name '*.a' -delete && \
>     find /opt/conda/ -follow -type f -name '*.js.map' -delete && \
>     /opt/conda/bin/conda clean -afy
> ```
> {: .source}
{: .callout}


ENV LANG=C.UTF-8 LC_ALL=C.UTF-8
ENV PATH /opt/conda/bin:$PATH


> ## Some `ENV` best practices
> 
> Note the definition of the variables `LANG` and `LC_ALL`.  These variables are used to specify the language localisation, or *locale*, to the value *C.UTF-8* in this case.  
> The *locale* specification impacts text rendering, time/date formats, monetary formats, and language-specific characters.  Leaving this undefined can result, for some programs, in warnings or in characters being displayed inappropriately.  On the other end, setting the *locale* will avoid these issues, and should be considered as a best practice to enforce in any Dockerfile.
> 
> Talking of useful variable definitions, this is a good one, too:
> 
> ```
> ENV DEBIAN_FRONTEND="noninteractive"
> ```
> {: .source} 
> 
> Dockerfile installations are non-interactive by nature, *i.e.* no installer can ask you questions during the process.  This variable tells the shell you are not able to interact, so that no questions will be asked and default values will be picked instead.
{: .callout}
